#!/usr/bin/env python3
"""
Genera un informe de posibles issues en base a an√°lisis est√°tico del repositorio.
Ideal para prellenar docs/issues.md o crear issues autom√°ticas por API.
"""

import os
import re

repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
ignored_dirs = {".git", "node_modules", "__pycache__", "venv", ".venv"}

potential_issues = []

def scan_file(filepath):
    issues = []
    with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
        content = f.read()

        if "TODO" in content:
            issues.append("‚ùó Contiene 'TODO', posiblemente tareas pendientes.")
        if "FIXME" in content:
            issues.append("üîß Contiene 'FIXME', c√≥digo que requiere revisi√≥n o correcci√≥n.")
        if re.search(r"(#\s*debug|print\s*\()", content):
            issues.append("ü™≤ Posible c√≥digo de depuraci√≥n sin eliminar.")
        if re.search(r"(password|token|secret)[\s:=]", content, re.IGNORECASE):
            issues.append("‚ö†Ô∏è Posible manejo inseguro de credenciales.")
        if filepath.endswith(".sh") and "chmod 777" in content:
            issues.append("‚ö†Ô∏è Uso de 'chmod 777' detectado, posible riesgo de seguridad.")

    return issues


def analyze():
    for root, dirs, files in os.walk(repo_root):
        dirs[:] = [d for d in dirs if d not in ignored_dirs]
        for file in files:
            if file.endswith((".py", ".sh", ".md", ".yml", ".yaml")):
                full_path = os.path.join(root, file)
                findings = scan_file(full_path)
                if findings:
                    rel_path = os.path.relpath(full_path, repo_root)
                    potential_issues.append((rel_path, findings))

    if not potential_issues:
        print("‚úÖ No se detectaron posibles issues.")
        return

    with open(os.path.join(repo_root, "docs/issues.md"), "w", encoding="utf-8") as f:
        f.write("# üêû Issues Detectadas Autom√°ticamente\n\n")
        f.write("Generado autom√°ticamente por `analyze_repo_for_issues.py`\n\n")
        for path, issues in potential_issues:
            f.write(f"## üìÑ {path}\n")
            for issue in issues:
                f.write(f"- {issue}\n")
            f.write("\n")

    print("‚úÖ Informe generado en docs/issues.md")

if __name__ == "__main__":
    analyze()
